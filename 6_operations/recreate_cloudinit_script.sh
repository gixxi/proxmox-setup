#!/bin/bash
# Recreate Cloud-Init Script for Existing VM
# Usage: ./recreate_cloudinit_script.sh <VM_ID> <VM_NAME> <CI_PASSWORD> [options]
# Example: ./recreate_cloudinit_script.sh 108 planet-rocklog-zentralbibliothek mypassword

# Default values
TIMEZONE="Europe/Zurich"
SSH_PUB_KEY_PATH="/root/.ssh/id_rsa.pub"
GATEWAY="192.168.3.1"

# Function to show usage
show_usage() {
    echo "Usage: $0 <VM_ID> <VM_NAME> <CI_PASSWORD> [options]"
    echo ""
    echo "Mandatory parameters:"
    echo "  VM_ID         VM ID number"
    echo "  VM_NAME       VM name/hostname"
    echo "  CI_PASSWORD   Password for root user"
    echo ""
    echo "Optional parameters:"
    echo "  --gateway, -g      Network gateway (default: $GATEWAY)"
    echo "  --timezone, -t     Timezone (default: $TIMEZONE)"
    echo "  --ssh-key          SSH public key path (default: $SSH_PUB_KEY_PATH)"
    echo "  --help, -h         Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 108 planet-rocklog-zentralbibliothek mypassword"
    echo "  $0 108 myvm mypass --gateway 192.168.1.1 --timezone America/New_York"
}

# Check minimum required parameters
if [ $# -lt 3 ]; then
    echo "Error: Missing required parameters"
    show_usage
    exit 1
fi

VM_ID="$1"
VM_NAME="$2"
CI_PASSWORD="$3"
shift 3

# Parse optional parameters
while [[ $# -gt 0 ]]; do
    case $1 in
        --gateway|-g)
            GATEWAY="$2"
            shift 2
            ;;
        --timezone|-t)
            TIMEZONE="$2"
            shift 2
            ;;
        --ssh-key)
            SSH_PUB_KEY_PATH="$2"
            shift 2
            ;;
        --help|-h)
            show_usage
            exit 0
            ;;
        *)
            echo "Error: Unknown parameter '$1'"
            show_usage
            exit 1
            ;;
    esac
done

# Validate inputs
if ! [[ "$VM_ID" =~ ^[0-9]+$ ]]; then
    echo "Error: VM_ID must be a number: $VM_ID"
    exit 1
fi

if [ ! -f "$SSH_PUB_KEY_PATH" ]; then
    echo "Error: SSH public key not found at $SSH_PUB_KEY_PATH"
    exit 1
fi

# Check if VM exists
if ! qm status $VM_ID > /dev/null 2>&1; then
    echo "ERROR: VM $VM_ID does not exist or is not accessible."
    exit 1
fi

SNIPPET_DIR="/var/lib/vz/snippets"
CUSTOM_SCRIPT_NAME="custom-$VM_NAME.sh"
CUSTOM_SCRIPT_PATH="$SNIPPET_DIR/$CUSTOM_SCRIPT_NAME"

echo "=================================================="
echo " RECREATING CLOUD-INIT SCRIPT FOR VM $VM_ID"
echo "=================================================="
echo " VM ID:           $VM_ID"
echo " VM Name:         $VM_NAME"
echo " Gateway:         $GATEWAY"
echo " Script Path:     $CUSTOM_SCRIPT_PATH"
echo " Timezone:        $TIMEZONE"
echo " SSH Key Path:    $SSH_PUB_KEY_PATH"
echo "=================================================="
echo ""

# Create Cloud-Init User Data Script
echo "INFO: Creating Cloud-Init user data script at ${CUSTOM_SCRIPT_PATH}..."
mkdir -p "$SNIPPET_DIR"

# Read the SSH public key content
SSH_PUB_KEY_CONTENT=$(cat "$SSH_PUB_KEY_PATH")

cat > "${CUSTOM_SCRIPT_PATH}" << EOF
#!/bin/bash
# Cloud-Init User Data Script for ${VM_NAME} (VM ID: ${VM_ID})
# Generated by recreate_cloudinit_script.sh

export DEBIAN_FRONTEND=noninteractive

echo "--- Starting Cloud-Init User Data Script ---"

# Set the hostname
echo "INFO: Setting hostname to ${VM_NAME}..."
hostnamectl set-hostname ${VM_NAME}
if [ \$? -ne 0 ]; then echo "WARNING: Failed to set hostname."; fi

# Force set root password directly
echo 'root:${CI_PASSWORD}' | chpasswd
echo "INFO: Root password has been explicitly set to the provided cloud-init password"

# Ensure SSH directory exists with proper permissions
mkdir -p /root/.ssh
chmod 700 /root/.ssh

# Simply create the authorized_keys file with the SSH key
echo "${SSH_PUB_KEY_CONTENT}" > /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
echo "INFO: SSH key added to authorized_keys"

# Basic System Setup
echo "INFO: Updating package lists and upgrading packages..."
apt-get update -y && apt-get upgrade -y
if [ \$? -ne 0 ]; then echo "WARNING: apt update/upgrade failed."; fi

echo "INFO: Installing base packages including nginx..."
apt-get install -y docker.io supervisor emacs vim nano curl wget parted gdisk mosh nginx zsh tmux make
if [ \$? -ne 0 ]; then echo "WARNING: apt install failed."; fi

# Mask systemd-networkd-wait-online.service to prevent network wait delays
systemctl mask systemd-networkd-wait-online.service || true

# Restart Docker to apply new configuration
systemctl restart docker
if [ \$? -ne 0 ]; then echo "WARNING: Failed to restart Docker service"; fi

# --- Configure Nginx ---
echo "INFO: Configuring Nginx..."
NGINX_CONF="/etc/nginx/nginx.conf"
NGINX_CONF_BAK="/etc/nginx/nginx.conf.bak"

# Backup the original config
if [ -f "\$NGINX_CONF" ]; then
    echo "Backing up default Nginx config to \$NGINX_CONF_BAK"
    cp "\$NGINX_CONF" "\$NGINX_CONF_BAK"
fi

# Create the new nginx.conf with desired settings
cat > "\$NGINX_CONF" << 'NGINX_EOF'
user www-data;
worker_processes auto; # Adjust based on CPU cores if needed
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    # Support large number of connections
    worker_connections 20000;
    # multi_accept on; # Uncomment if needed for high connection rates
}

http {
    # Handle large file uploads
    client_max_body_size 10M;

    ##
    # Basic Settings
    ##
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on; # Often used with tcp_nopush and sendfile
    keepalive_timeout 65;
    types_hash_max_size 2048;
    # server_tokens off; # Uncomment to hide Nginx version

    # server_names_hash_bucket_size 64; # Uncomment if long server names are used
    # server_name_in_redirect off;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    ##
    # SSL Settings (Sensible defaults, customize further in vhosts)
    ##
    ssl_protocols TLSv1.2 TLSv1.3; # Modern protocols
    ssl_prefer_server_ciphers on;
    # Add recommended ciphers here or in vhost configs if needed
    # ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:...';

    ##
    # Logging Settings
    ##
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    ##
    # Gzip Settings
    ##
    gzip on;
    gzip_disable "msie6"; # Disable for old IE versions
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6; # Balance between CPU and compression ratio
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_min_length 256; # Don't gzip very small files
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript image/svg+xml;

    ##
    # Virtual Host Configs
    ##
    include /etc/nginx/conf.d/*.conf;
    # Include individual .conf files from sites-enabled
    include /etc/nginx/sites-enabled/*.conf;
    # Explicitly include the standard default site if it exists
    include /etc/nginx/sites-enabled/default;
}
NGINX_EOF

echo "INFO: New Nginx configuration written to \$NGINX_CONF"

# Check Nginx configuration syntax
nginx -t
if [ \$? -ne 0 ]; then
    echo "ERROR: Nginx configuration test failed. Restoring backup."
    if [ -f "\$NGINX_CONF_BAK" ]; then
        cp "\$NGINX_CONF_BAK" "\$NGINX_CONF"
    fi
    # Decide how to handle this - maybe exit or just warn?
    # For now, we'll proceed but Nginx might fail to start/reload
else
    echo "INFO: Nginx configuration test successful."
fi

# Restart Nginx to apply changes
echo "INFO: Restarting Nginx service..."
systemctl restart nginx
if [ \$? -ne 0 ]; then
    echo "WARNING: Failed to restart Nginx service. Check config and logs."
fi
# --- End Nginx Configuration ---

echo "INFO: Enabling and starting Docker service..."
systemctl enable --now docker
if [ \$? -ne 0 ]; then echo "WARNING: Failed to enable/start docker."; fi

# Configure SSH settings (Allowing root login and password auth)
echo "INFO: Configuring SSH authentication settings..."
sed -i 's/#PasswordAuthentication.*/PasswordAuthentication yes/' /etc/ssh/sshd_config
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
sed -i 's/PermitRootLogin no/PermitRootLogin yes/' /etc/ssh/sshd_config
sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
sed -i 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config

# Ensure these settings are present (append if not found)
grep -q "^PasswordAuthentication yes" /etc/ssh/sshd_config || echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config
grep -q "^PermitRootLogin yes" /etc/ssh/sshd_config || echo "PermitRootLogin yes" >> /etc/ssh/sshd_config
grep -q "^PubkeyAuthentication yes" /etc/ssh/sshd_config || echo "PubkeyAuthentication yes" >> /etc/ssh/sshd_config

# Restart SSH service to apply changes
systemctl restart sshd
if [ \$? -ne 0 ]; then echo "WARNING: Failed to restart sshd service"; fi

# Timezone
echo "INFO: Setting timezone to ${TIMEZONE}..."
timedatectl set-timezone ${TIMEZONE}

# --- Configure DNS ---
echo "INFO: Configuring DNS servers..."
# Backup original resolv.conf
cp /etc/resolv.conf /etc/resolv.conf.backup 2>/dev/null || echo "No backup needed"

# Create new resolv.conf with proper DNS servers
cat > /etc/resolv.conf << RESOLV_EOF
# DNS configuration for ${VM_NAME}
# Primary: Router/Gateway (matches Proxmox host network)
nameserver ${GATEWAY}
# Secondary: Google DNS
nameserver 8.8.8.8
# Tertiary: Cloudflare DNS
nameserver 1.1.1.1
# Search domain (optional)
search local
RESOLV_EOF

echo "INFO: DNS configuration written to /etc/resolv.conf"
echo "INFO: Testing DNS resolution..."
nslookup google.com 2>/dev/null && echo "DNS resolution working" || echo "WARNING: DNS resolution failed"

# Test internet connectivity
echo "INFO: Testing internet connectivity..."
ping -c 1 8.8.8.8 >/dev/null 2>&1 && echo "Internet connectivity working" || echo "WARNING: Internet connectivity failed"

# --- No Firewall Configuration ---
echo "INFO: Skipping firewall configuration - relying on external firewall/network security..."

echo "--- Cloud-Init User Data Script Finished ---"

# Optional: Print SSH configuration for verification
echo "SSH configuration summary:"
grep -E "^(PasswordAuthentication|PermitRootLogin|PubkeyAuthentication)" /etc/ssh/sshd_config

# Optional: Print Nginx status
echo "Nginx service status:"
systemctl status nginx --no-pager || echo "Could not get Nginx status."

cat /etc/ssh/sshd_config

EOF

chmod +x "${CUSTOM_SCRIPT_PATH}"
echo "✅ Cloud-Init script created successfully at ${CUSTOM_SCRIPT_PATH}"

# Attach the Cloud-Init Script to the VM
echo "INFO: Attaching Cloud-Init script ${CUSTOM_SCRIPT_NAME} to VM $VM_ID..."
qm set $VM_ID --cicustom "user=local:snippets/${CUSTOM_SCRIPT_NAME}"
if [ $? -ne 0 ]; then
    echo "ERROR: Failed to attach cloud-init script for VM $VM_ID."
    exit 1
else
    echo "✅ Cloud-Init script attached successfully to VM $VM_ID"
fi

echo ""
echo "=================================================="
echo " CLOUD-INIT SCRIPT RECREATION COMPLETE"
echo "=================================================="
echo " Script created:  $CUSTOM_SCRIPT_PATH"
echo " Attached to VM:  $VM_ID"
echo " VM Name:         $VM_NAME"
echo ""
echo "NEXT STEPS:"
echo "1. Verify the script attachment: qm config $VM_ID | grep cicustom"
echo "2. Check the Hardware tab in Proxmox UI - should show CloudInit Drive"
echo "3. Go to Cloud-Init tab to configure additional settings"
echo "4. Regenerate cloud-init: qm cloudinit dump $VM_ID user"
echo "5. Restart the VM to apply changes: qm restart $VM_ID"
echo "==================================================" 